// PulseForge — Market Macro Intelligence Dashboard
// Loads data from /data/*.json (generated by GitHub Actions pipeline)
// OR from Google Apps Script if APPS_SCRIPT_URL is configured.

// ── Google Sheets Config ──────────────────────────────────────────────────
// To use Google Sheets as the data backend:
//   1. Deploy PulseForge/appsscript/Code.gs as a Web App in Google Apps Script UI
//   2. Copy the deployment URL and paste it below
//   3. Set access to "Anyone" when deploying
const APPS_SCRIPT_URL = 'https://script.google.com/macros/s/AKfycbyVGZRO4XVS0UPhzVRYJJH-_LrAHAAiBkiYo9Ko1qJk_JlaITcCyvITMDxzVEEKTzkd/exec';
const USE_SHEETS = APPS_SCRIPT_URL !== '';

const DATA_BASE = 'data';
const LS_KEY = 'pf_watchlist_v2';
const DEFAULT_TICKERS = ['TSLA', 'PLTR', 'AMZN', 'HOOD', 'SOFI', 'RIVN', 'NIO'];

const PLOTLY_DARK = {
    paper_bgcolor: 'rgba(0,0,0,0)',
    plot_bgcolor: 'rgba(0,0,0,0)',
    font: { family: 'Inter, sans-serif', color: '#94a3b8', size: 12 },
    xaxis: { gridcolor: '#1e293b', linecolor: '#2a3a4e', zerolinecolor: '#2a3a4e' },
    yaxis: { gridcolor: '#1e293b', linecolor: '#2a3a4e', zerolinecolor: '#2a3a4e' },
    margin: { l: 50, r: 20, t: 30, b: 40 },
    hoverlabel: { bgcolor: '#1a2332', bordercolor: '#3b82f6', font: { color: '#e2e8f0' } }
};
const PLOTLY_CONFIG = { responsive: true, displayModeBar: false };

// ── Utilities ──
function fmt(n, decimals = 2) {
    if (n == null) return '--';
    return Number(n).toLocaleString('en-US', { minimumFractionDigits: decimals, maximumFractionDigits: decimals });
}

function fmtChange(current, previous) {
    if (current == null || previous == null) return { text: '--', cls: 'flat' };
    const diff = current - previous;
    const pct = ((diff / Math.abs(previous)) * 100).toFixed(2);
    const sign = diff >= 0 ? '+' : '';
    const cls = diff > 0 ? 'up' : diff < 0 ? 'down' : 'flat';
    return { text: `${sign}${pct}%`, cls };
}

function regimeColor(score) {
    if (score < 30) return { label: 'EXTREME FEAR', cls: 'fear', color: '#ef4444' };
    if (score < 45) return { label: 'FEAR', cls: 'fear', color: '#f97316' };
    if (score < 55) return { label: 'NEUTRAL', cls: 'neutral', color: '#f59e0b' };
    if (score < 70) return { label: 'GREED', cls: 'neutral', color: '#84cc16' };
    return { label: 'EXTREME GREED', cls: 'greed', color: '#10b981' };
}

async function loadJSON(filename) {
    try {
        const resp = await fetch(`${DATA_BASE}/${filename}`);
        if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
        return await resp.json();
    } catch (e) {
        console.warn(`Failed to load ${filename}:`, e.message);
        return null;
    }
}

// ── Google Sheets Loader ──────────────────────────────────────────────────
/**
 * Fetch all data from Google Apps Script endpoint.
 * Returns an object { metrics, pulse, sectors, watchlist, vol, predictions, macro }
 * matching the format expected by the render functions.
 */
async function loadFromSheets() {
    try {
        console.log('[PulseForge] Loading data from Google Sheets...');
        const resp = await fetch(APPS_SCRIPT_URL);
        if (!resp.ok) throw new Error(`Apps Script HTTP ${resp.status}`);
        const d = await resp.json();
        if (d.error) throw new Error(`Apps Script error: ${d.error}`);

        // Map Apps Script response → existing data formats
        // pulse: already in { dates, scores, signals, current_score, last_updated }
        const pulse = d.pulse || null;

        // sectors: Apps Script returns array of {name, symbol, price, change_pct}
        // Old format: { last_updated, sectors: { "Technology": { symbol, price, change_pct } } }
        const sectors = d.sectors && d.sectors.length > 0 ? {
            last_updated: d.last_updated,
            sectors: Object.fromEntries(d.sectors.map(s => [
                s.name, { symbol: s.symbol, price: s.price, change_pct: s.change_pct }
            ]))
        } : null;

        // watchlist: Apps Script returns array of {ticker, price, change_pct, volume, signal, notes}
        // Old format: { last_updated, stocks: [...] }
        const watchlist = d.watchlist && d.watchlist.length > 0 ? {
            last_updated: d.last_updated,
            stocks: d.watchlist
        } : null;

        // volatility: Apps Script returns { vix_history: {dates, values}, vix_sma: {dates, values} }
        const vol = d.volatility || null;

        // predictions: Apps Script returns array of {name, direction, confidence, horizon, rationale}
        // Old format: { last_updated, predictions: [...] }
        const predictions = d.predictions && d.predictions.length > 0 ? {
            last_updated: d.last_updated,
            predictions: d.predictions.map(p => ({
                name: p.name,
                direction: p.direction,
                confidence: p.confidence,
                horizon: p.horizon,
                rationale: p.rationale
            }))
        } : null;

        // macro: Apps Script returns { notes: [...] }
        const macro = d.macro || null;

        // metrics: not stored in Sheets — fall back to JSON file
        const metrics = await loadJSON('metrics.json');

        // Extract the real pipeline push timestamp (stored in the Predictions timestamp column).
        // This is when data was *written* to Sheets, not when the page fetched it.
        let data_pushed_at = null;
        if (d.predictions && d.predictions.length > 0 && d.predictions[0].timestamp) {
            data_pushed_at = String(d.predictions[0].timestamp);
        } else if (d.pulse && d.pulse.dates && d.pulse.dates.length > 0) {
            data_pushed_at = d.pulse.dates[d.pulse.dates.length - 1]; // date-only fallback
        }

        console.log('[PulseForge] Sheets data loaded successfully. Push time:', data_pushed_at);
        return { metrics, pulse, sectors, watchlist, vol, predictions, macro, data_pushed_at, source: 'sheets' };
    } catch (e) {
        console.warn('[PulseForge] Sheets load failed, falling back to JSON files:', e.message);
        return null;
    }
}

// ── Watchlist Management ──
function getWatchlist() {
    try {
        const saved = localStorage.getItem(LS_KEY);
        if (saved) return JSON.parse(saved);
    } catch (e) {}
    return [...DEFAULT_TICKERS];
}

function saveWatchlist(tickers) {
    localStorage.setItem(LS_KEY, JSON.stringify(tickers));
}

function addTicker() {
    const input = document.getElementById('tickerInput');
    const ticker = input.value.trim().toUpperCase().replace(/[^A-Z]/g, '');
    if (!ticker) return;
    const list = getWatchlist();
    if (list.includes(ticker)) { input.value = ''; return; }
    list.push(ticker);
    saveWatchlist(list);
    input.value = '';
    renderChartsTab();
}

function removeTicker(ticker) {
    const list = getWatchlist().filter(t => t !== ticker);
    saveWatchlist(list);
    renderChartsTab();
}

// ── Tab Switching ──
function switchTab(name, btn) {
    document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
    document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
    btn.classList.add('active');
    document.getElementById('tab-' + name).classList.add('active');
    if (name === 'charts') renderChartsTab();
}

// ── Sparkline ──
function renderSparkline(elementId, values, color = '#3b82f6') {
    const el = document.getElementById(elementId);
    if (!el || !values || values.length < 2) return;
    Plotly.newPlot(el, [{
        y: values.slice(-30), type: 'scatter', mode: 'lines',
        line: { color, width: 1.5, shape: 'spline' },
        fill: 'tozeroy',
        fillcolor: color.replace(')', ', 0.1)').replace('rgb', 'rgba'),
        hoverinfo: 'skip'
    }], {
        ...PLOTLY_DARK,
        margin: { l: 0, r: 0, t: 0, b: 0 },
        xaxis: { visible: false }, yaxis: { visible: false }, height: 40
    }, { ...PLOTLY_CONFIG, staticPlot: true });
}

// ── Overview Renders ──
function renderMetrics(data) {
    if (!data) return;
    const metrics = [
        { id: 'vix', key: 'VIX', color: '#ef4444', decimals: 2, prefix: '', suffix: '' },
        { id: 'spy', key: 'SPY', color: '#3b82f6', decimals: 2, prefix: '$', suffix: '' },
        { id: 'dxy', key: 'DXY', color: '#8b5cf6', decimals: 2, prefix: '', suffix: '' },
        { id: 'tny', key: 'TNX', color: '#f59e0b', decimals: 2, prefix: '', suffix: '%' },
        { id: 'btc', key: 'BTC', color: '#f97316', decimals: 0, prefix: '$', suffix: '' },
        { id: 'oil', key: 'CL', color: '#10b981', decimals: 2, prefix: '$', suffix: '' }
    ];
    metrics.forEach(({ id, key, color, decimals, prefix, suffix }) => {
        const series = data[key];
        if (!series) return;
        const values = series.values || [];
        const current = values[values.length - 1];
        const previous = values[values.length - 2];
        document.getElementById(`${id}Value`).textContent = `${prefix}${fmt(current, decimals)}${suffix}`;
        const change = fmtChange(current, previous);
        const changeEl = document.getElementById(`${id}Change`);
        changeEl.textContent = change.text;
        changeEl.className = `metric-change ${change.cls}`;
        renderSparkline(`${id}Spark`, values, color);
    });
}

function renderPulseChart(data) {
    if (!data || !data.dates || !data.scores) return;
    const colors = data.scores.map(s => s < 30 ? '#ef4444' : s < 45 ? '#f97316' : s < 55 ? '#f59e0b' : s < 70 ? '#84cc16' : '#10b981');
    Plotly.newPlot('pulseChart', [
        { x: data.dates, y: data.scores, type: 'scatter', mode: 'lines+markers',
          line: { color: '#3b82f6', width: 2, shape: 'spline' },
          marker: { color: colors, size: 5 },
          fill: 'tozeroy', fillcolor: 'rgba(59,130,246,0.08)', name: 'Pulse Score' },
        { x: data.dates, y: Array(data.dates.length).fill(30), type: 'scatter', mode: 'lines',
          line: { color: '#ef4444', width: 1, dash: 'dot' }, name: 'Fear Zone', hoverinfo: 'skip' },
        { x: data.dates, y: Array(data.dates.length).fill(70), type: 'scatter', mode: 'lines',
          line: { color: '#10b981', width: 1, dash: 'dot' }, name: 'Greed Zone', hoverinfo: 'skip' }
    ], {
        ...PLOTLY_DARK, showlegend: true,
        legend: { orientation: 'h', y: -0.15, font: { size: 11 } },
        yaxis: { ...PLOTLY_DARK.yaxis, range: [0, 100], title: 'Pulse Score' }, height: 380
    }, PLOTLY_CONFIG);

    const latestScore = data.scores[data.scores.length - 1];
    if (latestScore != null) {
        const regime = regimeColor(latestScore);
        document.getElementById('pulseScore').textContent = Math.round(latestScore);
        document.getElementById('pulseScore').style.color = regime.color;
        const regimeEl = document.getElementById('pulseRegime');
        regimeEl.textContent = regime.label;
        regimeEl.className = `pulse-regime ${regime.cls}`;
    }
}

function renderSectorChart(data) {
    if (!data || !data.sectors) return;
    const sectors = data.sectors;
    const names = Object.keys(sectors);
    const values = names.map(n => sectors[n].change_pct);
    const colors = values.map(v => v >= 0 ? '#10b981' : '#ef4444');
    Plotly.newPlot('sectorChart', [{
        x: names, y: values, type: 'bar',
        marker: { color: colors, line: { color: colors.map(c => c === '#10b981' ? '#059669' : '#dc2626'), width: 1 } },
        text: values.map(v => `${v >= 0 ? '+' : ''}${v.toFixed(2)}%`),
        textposition: 'outside',
        textfont: { family: 'JetBrains Mono', size: 11, color: '#94a3b8' },
        hovertemplate: '%{x}: %{y:.2f}%<extra></extra>'
    }], {
        ...PLOTLY_DARK,
        yaxis: { ...PLOTLY_DARK.yaxis, title: 'Change %', zeroline: true, zerolinecolor: '#3b82f6', zerolinewidth: 2 },
        height: 350
    }, PLOTLY_CONFIG);
}

function renderWatchlist(data) {
    if (!data || !data.stocks) return;
    const table = document.getElementById('watchlistTable');
    let html = `<table><thead><tr>
        <th>Ticker</th><th>Price</th><th>Change</th><th>Volume</th><th>Signal</th><th>Notes</th>
    </tr></thead><tbody>`;
    data.stocks.forEach(s => {
        const changeCls = s.change_pct >= 0 ? 'up' : 'down';
        const signalCls = s.signal === 'BULLISH' ? 'bullish' : s.signal === 'BEARISH' ? 'bearish' : 'neutral';
        html += `<tr>
            <td class="ticker-cell">${s.ticker}</td>
            <td>$${fmt(s.price)}</td>
            <td class="metric-change ${changeCls}">${s.change_pct >= 0 ? '+' : ''}${fmt(s.change_pct)}%</td>
            <td>${s.volume ? (s.volume / 1e6).toFixed(1) + 'M' : '--'}</td>
            <td><span class="signal ${signalCls}">${s.signal || '--'}</span></td>
            <td style="color:var(--text-muted);font-family:var(--font-sans);font-size:0.8rem;">${s.notes || ''}</td>
        </tr>`;
    });
    html += '</tbody></table>';
    table.innerHTML = html;
}

function renderVolChart(data) {
    if (!data) return;
    const traces = [];
    if (data.vix_history) traces.push({
        x: data.vix_history.dates, y: data.vix_history.values, type: 'scatter', mode: 'lines',
        name: 'VIX', line: { color: '#ef4444', width: 2 },
        fill: 'tozeroy', fillcolor: 'rgba(239,68,68,0.08)'
    });
    if (data.vix_sma) traces.push({
        x: data.vix_sma.dates, y: data.vix_sma.values, type: 'scatter', mode: 'lines',
        name: 'VIX 20-SMA', line: { color: '#f59e0b', width: 1.5, dash: 'dash' }
    });
    if (traces.length) Plotly.newPlot('volChart', traces, {
        ...PLOTLY_DARK, showlegend: true,
        legend: { orientation: 'h', y: -0.15 },
        yaxis: { ...PLOTLY_DARK.yaxis, title: 'VIX Level' },
        shapes: [
            { type: 'line', y0: 20, y1: 20, x0: 0, x1: 1, xref: 'paper', line: { color: '#f59e0b', width: 1, dash: 'dot' } },
            { type: 'line', y0: 30, y1: 30, x0: 0, x1: 1, xref: 'paper', line: { color: '#ef4444', width: 1, dash: 'dot' } }
        ],
        height: 350
    }, PLOTLY_CONFIG);
}

function renderPredictions(data) {
    if (!data || !data.predictions) return;
    const grid = document.getElementById('predictionsGrid');
    grid.innerHTML = data.predictions.map(p => {
        const signalCls = p.direction === 'BULLISH' ? 'bullish' : p.direction === 'BEARISH' ? 'bearish' : 'neutral';
        return `<div class="prediction-card">
            <h3>${p.name}</h3>
            <div class="signal ${signalCls}">${p.direction} ${p.direction === 'BULLISH' ? '↑' : p.direction === 'BEARISH' ? '↓' : '→'}</div>
            <div class="confidence">Confidence: ${p.confidence}% · Horizon: ${p.horizon}</div>
            <div style="margin-top:0.5rem;font-size:0.8rem;color:var(--text-muted);">${p.rationale || ''}</div>
        </div>`;
    }).join('');
}

function renderMacroNotes(data) {
    if (!data || !data.notes) return;
    document.getElementById('macroNotes').innerHTML = '<ul>' + data.notes.map(n => `<li>${n}</li>`).join('') + '</ul>';
}

// ── Lightweight Charts Tab ──
let lwInstances = {}; // ticker -> chart instance (for cleanup)

async function renderChartsTab() {
    const tickers = getWatchlist();
    const grid = document.getElementById('lwChartsGrid');
    const wmTickers = document.getElementById('wmTickers');

    // Render ticker pills
    wmTickers.innerHTML = tickers.map(t =>
        `<span class="wm-pill">
            ${t}
            <button class="wm-remove" onclick="removeTicker('${t}')" title="Remove ${t}">×</button>
        </span>`
    ).join('');

    // Destroy old chart instances
    Object.values(lwInstances).forEach(c => { try { c.remove(); } catch(e){} });
    lwInstances = {};

    // Build chart cards
    grid.innerHTML = tickers.map(t => `
        <div class="lw-card" id="lwcard-${t}">
            <div class="lw-card-header">
                <span class="lw-ticker">${t}</span>
                <span class="lw-price" id="lwprice-${t}">--</span>
                <span class="lw-change" id="lwchg-${t}">--</span>
            </div>
            <div class="lw-chart-wrap" id="lwchart-${t}"></div>
            <div class="lw-vol-wrap" id="lwvol-${t}"></div>
        </div>`
    ).join('');

    // Load candles for each ticker
    for (const ticker of tickers) {
        await renderSingleChart(ticker);
    }
}

async function renderSingleChart(ticker) {
    const data = await loadJSON(`candles/${ticker}.json`);
    const chartEl = document.getElementById(`lwchart-${ticker}`);
    const volEl = document.getElementById(`lwvol-${ticker}`);
    if (!chartEl) return;

    if (!data || !data.candles || data.candles.length === 0) {
        chartEl.innerHTML = `<div class="lw-nodata">No candle data for ${ticker}.<br><span>Will be available after next pipeline run.</span></div>`;
        return;
    }

    const candles = data.candles;
    const last = candles[candles.length - 1];
    const prev = candles[candles.length - 2];

    // Update price/change header
    const priceEl = document.getElementById(`lwprice-${ticker}`);
    const chgEl = document.getElementById(`lwchg-${ticker}`);
    if (priceEl) priceEl.textContent = `$${last.c.toFixed(2)}`;
    if (chgEl) {
        const chgPct = prev ? ((last.c - prev.c) / prev.c * 100) : 0;
        const sign = chgPct >= 0 ? '+' : '';
        chgEl.textContent = `${sign}${chgPct.toFixed(2)}%`;
        chgEl.className = `lw-change ${chgPct >= 0 ? 'up' : 'down'}`;
    }

    // Main candlestick chart
    const chart = LightweightCharts.createChart(chartEl, {
        width: chartEl.clientWidth || 480,
        height: 200,
        layout: { background: { type: 'solid', color: 'transparent' }, textColor: '#94a3b8' },
        grid: { vertLines: { color: '#1e293b' }, horzLines: { color: '#1e293b' } },
        crosshair: { mode: LightweightCharts.CrosshairMode.Normal },
        rightPriceScale: { borderColor: '#2a3a4e' },
        timeScale: { borderColor: '#2a3a4e', timeVisible: true },
        handleScroll: true,
        handleScale: true,
    });

    const candleSeries = chart.addSeries(LightweightCharts.CandlestickSeries, {
        upColor: '#10b981', downColor: '#ef4444',
        borderUpColor: '#10b981', borderDownColor: '#ef4444',
        wickUpColor: '#10b981', wickDownColor: '#ef4444',
    });

    const ohlcData = candles.map(c => ({
        time: Math.floor(c.t / 1000),
        open: c.o, high: c.h, low: c.l, close: c.c
    }));
    candleSeries.setData(ohlcData);
    chart.timeScale().fitContent();
    lwInstances[ticker] = chart;

    // Volume chart
    const volChart = LightweightCharts.createChart(volEl, {
        width: volEl.clientWidth || 480,
        height: 55,
        layout: { background: { type: 'solid', color: 'transparent' }, textColor: '#94a3b8' },
        grid: { vertLines: { visible: false }, horzLines: { visible: false } },
        rightPriceScale: { borderColor: '#2a3a4e', scaleMargins: { top: 0.1, bottom: 0 } },
        timeScale: { borderColor: '#2a3a4e', visible: false },
        handleScroll: false, handleScale: false,
    });

    const volSeries = volChart.addSeries(LightweightCharts.HistogramSeries, {
        priceFormat: { type: 'volume' },
        priceScaleId: '',
    });

    const volData = candles.map(c => ({
        time: Math.floor(c.t / 1000),
        value: c.v,
        color: c.c >= c.o ? 'rgba(16,185,129,0.5)' : 'rgba(239,68,68,0.5)'
    }));
    volSeries.setData(volData);
    volChart.timeScale().fitContent();

    // Sync time scales
    chart.timeScale().subscribeVisibleLogicalRangeChange(range => {
        if (range) volChart.timeScale().setVisibleLogicalRange(range);
    });
    volChart.timeScale().subscribeVisibleLogicalRangeChange(range => {
        if (range) chart.timeScale().setVisibleLogicalRange(range);
    });

    // Resize observer
    const observer = new ResizeObserver(() => {
        const w = chartEl.clientWidth;
        if (w > 0) { chart.resize(w, 200); volChart.resize(w, 55); }
    });
    observer.observe(chartEl);
}

// ── Data Source Status ──
function setDataStatus(connected, pushedAt) {
    const dot   = document.getElementById('dsDot');
    const label = document.getElementById('dsLabel');
    const time  = document.getElementById('lastUpdated');
    if (!dot) return;

    if (connected) {
        dot.className   = 'ds-dot connected';
        label.className = 'ds-label connected';
        label.textContent = 'Live';
        if (pushedAt) {
            try {
                const d = new Date(pushedAt);
                // If the value is date-only (no 'T'), just show the date
                const isDateOnly = !pushedAt.includes('T');
                if (isDateOnly) {
                    time.textContent = `Pushed ${d.toLocaleDateString('en-US', { timeZone: 'UTC', month: 'short', day: 'numeric' })}`;
                } else {
                    time.textContent = `Pushed ${d.toLocaleString('en-US', {
                        timeZone: 'America/New_York',
                        month: 'short', day: 'numeric',
                        hour: 'numeric', minute: '2-digit', hour12: true
                    })} ET`;
                }
            } catch (e) {
                time.textContent = `Pushed ${pushedAt}`;
            }
        } else {
            time.textContent = 'Push time unavailable';
        }
    } else {
        dot.className   = 'ds-dot offline';
        label.className = 'ds-label offline';
        label.textContent = 'Offline';
        time.textContent = 'Using cached data';
    }
}

// ── Main Init ──
async function init() {
    const timeEl = document.getElementById('lastUpdated');
    if (timeEl) timeEl.textContent = '–';

    let metrics, pulse, sectors, watchlist, vol, predictions, macro;
    let sheetsOk = false;
    let data_pushed_at = null;

    // Try Google Sheets first if configured, fallback to JSON files
    if (USE_SHEETS) {
        const sheetsData = await loadFromSheets();
        if (sheetsData) {
            ({ metrics, pulse, sectors, watchlist, vol, predictions, macro, data_pushed_at } = sheetsData);
            sheetsOk = true;
        }
    }

    // Fallback: load from individual JSON files (original behavior)
    if (!pulse) {
        [metrics, pulse, sectors, watchlist, vol, predictions, macro] = await Promise.all([
            loadJSON('metrics.json'), loadJSON('pulse.json'), loadJSON('sectors.json'),
            loadJSON('watchlist.json'), loadJSON('volatility.json'),
            loadJSON('predictions.json'), loadJSON('macro.json')
        ]);
    }

    renderMetrics(metrics);
    renderPulseChart(pulse);
    renderSectorChart(sectors);
    renderWatchlist(watchlist);
    renderVolChart(vol);
    renderPredictions(predictions);
    renderMacroNotes(macro);

    // Merge server watchlist with localStorage defaults if first visit
    if (!localStorage.getItem(LS_KEY) && watchlist?.stocks) {
        const tickers = watchlist.stocks.map(s => s.ticker);
        saveWatchlist(tickers);
    }

    // Show data source status — green dot = Sheets connected, push time = when pipeline last wrote
    setDataStatus(sheetsOk, data_pushed_at);
}

document.addEventListener('DOMContentLoaded', init);
